diff --git a/swagger-templates/ruby/README.mustache b/swagger-templates/ruby/README.mustache
index 076192b..4fb7d07 100644
--- a/swagger-templates/ruby/README.mustache
+++ b/swagger-templates/ruby/README.mustache
@@ -6,6 +6,10 @@
 {{{appDescription}}}
 {{/appDescription}}
 
+This repository contains the released Ruby client SDK. Check out our [API
+specification repository](https://github.com/square/connect-api-specification)
+for the specification and template files we used to generate this.
+
 This SDK is automatically generated by the [Swagger Codegen](https://github.com/swagger-api/swagger-codegen) project:
 
 - API version: {{appVersion}}
@@ -18,39 +22,18 @@ For more information, please visit [{{{infoUrl}}}]({{{infoUrl}}})
 
 ## Installation
 
-### Build a gem
+### Install from Rubygems (recommended)
 
-To build the Ruby code into a gem:
+The Ruby SDK is published on Rubygems. Simply run:
 
 ```shell
-gem build {{{gemName}}}.gemspec
+gem install {{{gemName}}}
 ```
 
-Then either install the gem locally:
-
-```shell
-gem install ./{{{gemName}}}-{{{gemVersion}}}.gem
-```
-(for development, run `gem install --dev ./{{{gemName}}}-{{{gemVersion}}}.gem` to install the development dependencies)
-
-or publish the gem to a gem hosting service, e.g. [RubyGems](https://rubygems.org/).
-
-Finally add this to the Gemfile:
-
-    gem '{{{gemName}}}', '~> {{{gemVersion}}}'
+Or add this to the Gemfile:
 
-### Install from Git
-
-If the Ruby gem is hosted at a git repository: https://github.com/{{#gitUserId}}{{.}}{{/gitUserId}}{{^gitUserId}}YOUR_GIT_USERNAME{{/gitUserId}}/{{#gitRepoId}}{{.}}{{/gitRepoId}}{{^gitRepoId}}YOUR_GIT_REPO{{/gitRepoId}}, then add the following in the Gemfile:
-
-    gem '{{{gemName}}}', :git => 'https://github.com/{{#gitUserId}}{{.}}{{/gitUserId}}{{^gitUserId}}YOUR_GIT_USERNAME{{/gitUserId}}/{{#gitRepoId}}{{.}}{{/gitRepoId}}{{^gitRepoId}}YOUR_GIT_REPO{{/gitRepoId}}.git'
-
-### Include the Ruby code directly
-
-Include the Ruby code directly using `-I` as follows:
-
-```shell
-ruby -Ilib script.rb
+```ruby
+gem '{{{gemName}}}', '~> {{{gemVersion}}}'
 ```
 
 ## Getting Started
diff --git a/swagger-templates/ruby/api_client.mustache b/swagger-templates/ruby/api_client.mustache
index fcd4b3e..5645c51 100644
--- a/swagger-templates/ruby/api_client.mustache
+++ b/swagger-templates/ruby/api_client.mustache
@@ -23,9 +23,18 @@ module {{moduleName}}
     # @option config [Configuration] Configuration for initializing the object, default to Configuration.default
     def initialize(config = Configuration.default)
       @config = config
-      @user_agent = "{{#httpUserAgent}}{{{.}}}{{/httpUserAgent}}{{^httpUserAgent}}Swagger-Codegen/#{VERSION}/ruby{{/httpUserAgent}}"
+
+      # Construct user agent string. Returns slightly different string for JRuby
+      @user_agent = "{{{gemName}}}/#{VERSION} "
+      if defined? JRUBY_VERSION
+        @user_agent += "(#{RUBY_ENGINE}/#{JRUBY_VERSION}:ruby/#{RUBY_VERSION})"
+      else
+        @user_agent += "(#{RUBY_ENGINE}/#{RUBY_VERSION}; #{RUBY_PLATFORM})"
+      end
+
       @default_headers = {
         'Content-Type' => "application/json",
+        'Accept' => "application/json",
         'User-Agent' => @user_agent
       }
     end
@@ -57,7 +66,7 @@ module {{moduleName}}
           fail ApiError.new(:code => response.code,
                             :response_headers => response.headers,
                             :response_body => response.body),
-               response.status_message
+               "#{response.status_message} - #{response.body}"
         end
       end
 
@@ -83,6 +92,13 @@ module {{moduleName}}
       http_method = http_method.to_sym.downcase
 
       header_params = @default_headers.merge(opts[:header_params] || {})
+
+      if header_params.has_key?(:Authorization)
+        if !header_params[:Authorization].start_with?("Bearer ")
+          header_params[:Authorization] = "Bearer " + header_params[:Authorization]
+        end
+      end
+
       query_params = opts[:query_params] || {}
       form_params = opts[:form_params] || {}
 
diff --git a/swagger-templates/ruby/api_client_spec.mustache b/swagger-templates/ruby/api_client_spec.mustache
deleted file mode 100644
index df32f34..0000000
--- a/swagger-templates/ruby/api_client_spec.mustache
+++ /dev/null
@@ -1,218 +0,0 @@
-=begin
-{{> api_info}}
-=end
-
-require 'spec_helper'
-
-describe {{moduleName}}::ApiClient do
-  context 'initialization' do
-    context 'URL stuff' do
-      context 'host' do
-        it 'removes http from host' do
-          {{moduleName}}.configure { |c| c.host = 'http://example.com' }
-          expect({{moduleName}}::Configuration.default.host).to eq('example.com')
-        end
-
-        it 'removes https from host' do
-          {{moduleName}}.configure { |c| c.host = 'https://wookiee.com' }
-          expect({{moduleName}}::ApiClient.default.config.host).to eq('wookiee.com')
-        end
-
-        it 'removes trailing path from host' do
-          {{moduleName}}.configure { |c| c.host = 'hobo.com/v4' }
-          expect({{moduleName}}::Configuration.default.host).to eq('hobo.com')
-        end
-      end
-
-      context 'base_path' do
-        it "prepends a slash to base_path" do
-          {{moduleName}}.configure { |c| c.base_path = 'v4/dog' }
-          expect({{moduleName}}::Configuration.default.base_path).to eq('/v4/dog')
-        end
-
-        it "doesn't prepend a slash if one is already there" do
-          {{moduleName}}.configure { |c| c.base_path = '/v4/dog' }
-          expect({{moduleName}}::Configuration.default.base_path).to eq('/v4/dog')
-        end
-
-        it "ends up as a blank string if nil" do
-          {{moduleName}}.configure { |c| c.base_path = nil }
-          expect({{moduleName}}::Configuration.default.base_path).to eq('')
-        end
-      end
-    end
-  end
-
-  describe "params_encoding in #build_request" do
-    let(:config) { {{moduleName}}::Configuration.new }
-    let(:api_client) { {{moduleName}}::ApiClient.new(config) }
-
-    it "defaults to nil" do
-      expect({{moduleName}}::Configuration.default.params_encoding).to eq(nil)
-      expect(config.params_encoding).to eq(nil)
-
-      request = api_client.build_request(:get, '/test')
-      expect(request.options[:params_encoding]).to eq(nil)
-    end
-
-    it "can be customized" do
-      config.params_encoding = :multi
-      request = api_client.build_request(:get, '/test')
-      expect(request.options[:params_encoding]).to eq(:multi)
-    end
-  end
-
-  describe "timeout in #build_request" do
-    let(:config) { {{moduleName}}::Configuration.new }
-    let(:api_client) { {{moduleName}}::ApiClient.new(config) }
-
-    it "defaults to 0" do
-      expect({{moduleName}}::Configuration.default.timeout).to eq(0)
-      expect(config.timeout).to eq(0)
-
-      request = api_client.build_request(:get, '/test')
-      expect(request.options[:timeout]).to eq(0)
-    end
-
-    it "can be customized" do
-      config.timeout = 100
-      request = api_client.build_request(:get, '/test')
-      expect(request.options[:timeout]).to eq(100)
-    end
-  end
-
-  describe "#deserialize" do
-    it "handles Array<Integer>" do
-      api_client = {{moduleName}}::ApiClient.new
-      headers = {'Content-Type' => 'application/json'}
-      response = double('response', headers: headers, body: '[12, 34]')
-      data = api_client.deserialize(response, 'Array<Integer>')
-      expect(data).to be_instance_of(Array)
-      expect(data).to eq([12, 34])
-    end
-
-    it "handles Array<Array<Integer>>" do
-      api_client = {{moduleName}}::ApiClient.new
-      headers = {'Content-Type' => 'application/json'}
-      response = double('response', headers: headers, body: '[[12, 34], [56]]')
-      data = api_client.deserialize(response, 'Array<Array<Integer>>')
-      expect(data).to be_instance_of(Array)
-      expect(data).to eq([[12, 34], [56]])
-    end
-
-    it "handles Hash<String, String>" do
-      api_client = {{moduleName}}::ApiClient.new
-      headers = {'Content-Type' => 'application/json'}
-      response = double('response', headers: headers, body: '{"message": "Hello"}')
-      data = api_client.deserialize(response, 'Hash<String, String>')
-      expect(data).to be_instance_of(Hash)
-      expect(data).to eq({:message => 'Hello'})
-    end
-  end
-
-  describe "#object_to_hash" do
-    it "ignores nils and includes empty arrays" do
-      # uncomment below to test object_to_hash for model
-      #api_client = {{moduleName}}::ApiClient.new
-      #_model = {{moduleName}}::ModelName.new
-      # update the model attribute below
-      #_model.id = 1 
-      # update the expected value (hash) below
-      #expected = {id: 1, name: '', tags: []}
-      #expect(api_client.object_to_hash(_model)).to eq(expected)
-    end
-  end
-
-  describe "#build_collection_param" do
-    let(:param) { ['aa', 'bb', 'cc'] }
-    let(:api_client) { {{moduleName}}::ApiClient.new }
-
-    it "works for csv" do
-      expect(api_client.build_collection_param(param, :csv)).to eq('aa,bb,cc')
-    end
-
-    it "works for ssv" do
-      expect(api_client.build_collection_param(param, :ssv)).to eq('aa bb cc')
-    end
-
-    it "works for tsv" do
-      expect(api_client.build_collection_param(param, :tsv)).to eq("aa\tbb\tcc")
-    end
-
-    it "works for pipes" do
-      expect(api_client.build_collection_param(param, :pipes)).to eq('aa|bb|cc')
-    end
-
-    it "works for multi" do
-      expect(api_client.build_collection_param(param, :multi)).to eq(['aa', 'bb', 'cc'])
-    end
-
-    it "fails for invalid collection format" do
-      expect(proc { api_client.build_collection_param(param, :INVALID) }).to raise_error(RuntimeError, 'unknown collection format: :INVALID')
-    end
-  end
-
-  describe "#json_mime?" do
-    let(:api_client) { {{moduleName}}::ApiClient.new }
-
-    it "works" do
-      expect(api_client.json_mime?(nil)).to eq false
-      expect(api_client.json_mime?('')).to eq false
-
-      expect(api_client.json_mime?('application/json')).to eq true
-      expect(api_client.json_mime?('application/json; charset=UTF8')).to eq true
-      expect(api_client.json_mime?('APPLICATION/JSON')).to eq true
-
-      expect(api_client.json_mime?('application/xml')).to eq false
-      expect(api_client.json_mime?('text/plain')).to eq false
-      expect(api_client.json_mime?('application/jsonp')).to eq false
-    end
-  end
-
-  describe "#select_header_accept" do
-    let(:api_client) { {{moduleName}}::ApiClient.new }
-
-    it "works" do
-      expect(api_client.select_header_accept(nil)).to be_nil
-      expect(api_client.select_header_accept([])).to be_nil
-
-      expect(api_client.select_header_accept(['application/json'])).to eq('application/json')
-      expect(api_client.select_header_accept(['application/xml', 'application/json; charset=UTF8'])).to eq('application/json; charset=UTF8')
-      expect(api_client.select_header_accept(['APPLICATION/JSON', 'text/html'])).to eq('APPLICATION/JSON')
-
-      expect(api_client.select_header_accept(['application/xml'])).to eq('application/xml')
-      expect(api_client.select_header_accept(['text/html', 'application/xml'])).to eq('text/html,application/xml')
-    end
-  end
-
-  describe "#select_header_content_type" do
-    let(:api_client) { {{moduleName}}::ApiClient.new }
-
-    it "works" do
-      expect(api_client.select_header_content_type(nil)).to eq('application/json')
-      expect(api_client.select_header_content_type([])).to eq('application/json')
-
-      expect(api_client.select_header_content_type(['application/json'])).to eq('application/json')
-      expect(api_client.select_header_content_type(['application/xml', 'application/json; charset=UTF8'])).to eq('application/json; charset=UTF8')
-      expect(api_client.select_header_content_type(['APPLICATION/JSON', 'text/html'])).to eq('APPLICATION/JSON')
-      expect(api_client.select_header_content_type(['application/xml'])).to eq('application/xml')
-      expect(api_client.select_header_content_type(['text/plain', 'application/xml'])).to eq('text/plain')
-    end
-  end
-
-  describe "#sanitize_filename" do
-    let(:api_client) { {{moduleName}}::ApiClient.new }
-
-    it "works" do
-      expect(api_client.sanitize_filename('sun')).to eq('sun')
-      expect(api_client.sanitize_filename('sun.gif')).to eq('sun.gif')
-      expect(api_client.sanitize_filename('../sun.gif')).to eq('sun.gif')
-      expect(api_client.sanitize_filename('/var/tmp/sun.gif')).to eq('sun.gif')
-      expect(api_client.sanitize_filename('./sun.gif')).to eq('sun.gif')
-      expect(api_client.sanitize_filename('..\sun.gif')).to eq('sun.gif')
-      expect(api_client.sanitize_filename('\var\tmp\sun.gif')).to eq('sun.gif')
-      expect(api_client.sanitize_filename('c:\var\tmp\sun.gif')).to eq('sun.gif')
-      expect(api_client.sanitize_filename('.\sun.gif')).to eq('sun.gif')
-    end
-  end
-end
diff --git a/swagger-templates/ruby/base_object_spec.mustache b/swagger-templates/ruby/base_object_spec.mustache
deleted file mode 100644
index 7376cd1..0000000
--- a/swagger-templates/ruby/base_object_spec.mustache
+++ /dev/null
@@ -1,109 +0,0 @@
-require 'spec_helper'
-
-class ArrayMapObject < Petstore::Category
-  attr_accessor :int_arr, :pet_arr, :int_map, :pet_map, :int_arr_map, :pet_arr_map, :boolean_true_arr, :boolean_false_arr
-
-  def self.attribute_map
-    {
-      :int_arr => :int_arr,
-      :pet_arr => :pet_arr,
-      :int_map => :int_map,
-      :pet_map => :pet_map,
-      :int_arr_map => :int_arr_map,
-      :pet_arr_map => :pet_arr_map,
-      :boolean_true_arr  => :boolean_true_arr,
-      :boolean_false_arr => :boolean_false_arr,
-    }
-  end
-
-  def self.swagger_types
-    {
-      :int_arr => :'Array<Integer>',
-      :pet_arr => :'Array<Pet>',
-      :int_map => :'Hash<String, Integer>',
-      :pet_map => :'Hash<String, Pet>',
-      :int_arr_map => :'Hash<String, Array<Integer>>',
-      :pet_arr_map => :'Hash<String, Array<Pet>>',
-      :boolean_true_arr  => :'Array<BOOLEAN>',
-      :boolean_false_arr => :'Array<BOOLEAN>',
-    }
-  end
-end
-
-describe 'BaseObject' do
-  describe 'boolean values' do
-    let(:obj) { Petstore::Cat.new({declawed: false}) }
-
-    it 'should have values set' do
-      expect(obj.declawed).not_to be_nil
-      expect(obj.declawed).to eq(false)
-    end
-  end
-
-  describe 'array and map properties' do
-    let(:obj) { ArrayMapObject.new }
-
-    let(:data) do
-      {int_arr: [123, 456],
-       pet_arr: [{name: 'Kitty'}],
-       int_map: {'int' => 123},
-       pet_map: {'pet' => {name: 'Kitty'}},
-       int_arr_map: {'int_arr' => [123, 456]},
-       pet_arr_map: {'pet_arr' => [{name: 'Kitty'}]},
-       boolean_true_arr:  [true, "true", "TruE", 1, "y", "yes", "1", "t", "T"],
-       boolean_false_arr: [false, "", 0, "0", "f", nil, "null"],
-      }
-    end
-
-    it 'works for #build_from_hash' do
-      obj.build_from_hash(data)
-
-      expect(obj.int_arr).to match_array([123, 456])
-
-      expect(obj.pet_arr).to be_instance_of(Array)
-      expect(obj.pet_arr).to be_instance_of(1)
-
-      pet = obj.pet_arr.first
-      expect(pet).to be_instance_of(Petstore::Pet)
-      expect(pet.name).to eq('Kitty')
-
-      expect(obj.int_map).to be_instance_of(Hash)
-      expect(obj.int_map).to eq({'int' => 123})
-
-      expect(obj.pet_map).to be_instance_of(Hash)
-      pet = obj.pet_map['pet']
-      expect(pet).to be_instance_of(Petstore::Pet)
-      expect(pet.name).to eq('Kitty')
-
-      expect(obj.int_arr_map).to be_instance_of(Hash)
-      arr = obj.int_arr_map['int_arr']
-      expect(arr).to match_array([123, 456])
-
-      expect(obj.pet_arr_map).to be_instance_of(Hash)
-      arr = obj.pet_arr_map['pet_arr']
-      expect(arr).to be_instance_of(Array)
-      expect(arr.size).to eq(1)
-      pet = arr.first
-      expect(pet).to be_instance_of(Petstore::Pet)
-      expect(pet.name).to eq('Kitty')
-
-      expect(obj.boolean_true_arr).to be_instance_of(Array)
-      obj.boolean_true_arr.each do |b|
-        expect(b).to eq(true)
-      end
-
-      expect(obj.boolean_false_arr).to be_instance_of(Array)
-      obj.boolean_false_arr.each do |b|
-        expect(b).to eq(false)
-      end
-    end
-
-    it 'works for #to_hash' do
-      obj.build_from_hash(data)
-      expect_data = data.dup
-      expect_data[:boolean_true_arr].map! {true}
-      expect_data[:boolean_false_arr].map! {false}
-      expect(obj.to_hash).to eq(expect_data)
-    end
-  end
-end
diff --git a/swagger-templates/ruby/configuration_spec.mustache b/swagger-templates/ruby/configuration_spec.mustache
deleted file mode 100644
index 2955eaa..0000000
--- a/swagger-templates/ruby/configuration_spec.mustache
+++ /dev/null
@@ -1,34 +0,0 @@
-=begin
-{{> api_info}}
-=end
-
-require 'spec_helper'
-
-describe {{moduleName}}::Configuration do
-  let(:config) { {{moduleName}}::Configuration.default }
-
-  before(:each) do
-    # uncomment below to setup host and base_path
-    #require 'URI'
-    #uri = URI.parse("{{{basePath}}}")
-    #{{moduleName}}.configure do |c|
-    #  c.host = uri.host
-    #  c.base_path = uri.path
-    #end
-  end
-
-  describe '#base_url' do
-    it 'should have the default value' do
-      # uncomment below to test default value of the base path
-      #expect(config.base_url).to eq("{{{basePath}}}")
-    end
-
-    it 'should remove trailing slashes' do
-      [nil, '', '/', '//'].each do |base_path|
-        config.base_path = base_path
-        # uncomment below to test trailing slashes
-        #expect(config.base_url).to eq("{{{basePath}}}")
-      end
-    end
-  end
-end
diff --git a/swagger-templates/ruby/git_push.sh.mustache b/swagger-templates/ruby/git_push.sh.mustache
deleted file mode 100755
index 3def114..0000000
--- a/swagger-templates/ruby/git_push.sh.mustache
+++ /dev/null
@@ -1,67 +0,0 @@
-#!/bin/sh
-#
-# Generated by: https://github.com/swagger-api/swagger-codegen.git
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# ref: https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/
-#
-# Usage example: /bin/sh ./git_push.sh wing328 swagger-petstore-perl "minor update"
-
-git_user_id=$1
-git_repo_id=$2
-release_note=$3
-
-if [ "$git_user_id" = "" ]; then
-    git_user_id="{{{gitUserId}}}"
-    echo "[INFO] No command line input provided. Set \$git_user_id to $git_user_id"
-fi
-
-if [ "$git_repo_id" = "" ]; then
-    git_repo_id="{{{gitRepoId}}}"
-    echo "[INFO] No command line input provided. Set \$git_repo_id to $git_repo_id"
-fi
-
-if [ "$release_note" = "" ]; then
-    release_note="{{{releaseNote}}}"
-    echo "[INFO] No command line input provided. Set \$release_note to $release_note"
-fi
-
-# Initialize the local directory as a Git repository
-git init
-
-# Adds the files in the local repository and stages them for commit.
-git add .
-
-# Commits the tracked changes and prepares them to be pushed to a remote repository.
-git commit -m "$release_note"
-
-# Sets the new remote
-git_remote=`git remote`
-if [ "$git_remote" = "" ]; then # git remote not defined
-
-    if [ "$GIT_TOKEN" = "" ]; then
-        echo "[INFO] \$GIT_TOKEN (environment variable) is not set. Using the git crediential in your environment."
-        git remote add origin https://github.com/${git_user_id}/${git_repo_id}.git
-    else
-        git remote add origin https://${git_user_id}:${GIT_TOKEN}@github.com/${git_user_id}/${git_repo_id}.git
-    fi
-
-fi
-
-git pull origin master
-
-# Pushes (Forces) the changes in the local repository up to the remote repository
-echo "Git pushing to https://github.com/${git_user_id}/${git_repo_id}.git"
-git push origin master 2>&1 | grep -v 'To https'
-
diff --git a/swagger-templates/ruby/model_test.mustache b/swagger-templates/ruby/model_test.mustache
deleted file mode 100644
index 0794015..0000000
--- a/swagger-templates/ruby/model_test.mustache
+++ /dev/null
@@ -1,45 +0,0 @@
-=begin
-{{> api_info}}
-=end
-
-require 'spec_helper'
-require 'json'
-require 'date'
-
-# Unit tests for {{moduleName}}::{{classname}}
-# Automatically generated by swagger-codegen (github.com/swagger-api/swagger-codegen)
-# Please update as you see appropriate
-{{#models}}{{#model}}describe '{{classname}}' do
-  before do
-    # run before each test
-    @instance = {{moduleName}}::{{classname}}.new
-  end
-
-  after do
-    # run after each test
-  end
-
-  describe 'test an instance of {{classname}}' do
-    it 'should create an instact of {{classname}}' do
-      expect(@instance).to be_instance_of({{moduleName}}::{{classname}})
-    end
-  end
-{{#vars}}
-  describe 'test attribute "{{{name}}}"' do
-    it 'should work' do
-       {{#isEnum}}
-       # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
-       #validator = Petstore::EnumTest::EnumAttributeValidator.new('{{{datatype}}}', [{{#allowableValues}}{{#values}}"{{{this}}}"{{^-last}}, {{/-last}}{{/values}}{{/allowableValues}}])
-       #validator.allowable_values.each do |value|
-       #  expect { @instance.{{name}} = value }.not_to raise_error
-       #end
-       {{/isEnum}}
-       {{^isEnum}}
-       # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
-       {{/isEnum}}
-    end
-  end
-
-{{/vars}}
-end
-{{/model}}{{/models}}
diff --git a/swagger-templates/ruby/rspec.mustache b/swagger-templates/ruby/rspec.mustache
deleted file mode 100644
index 83e16f8..0000000
--- a/swagger-templates/ruby/rspec.mustache
+++ /dev/null
@@ -1,2 +0,0 @@
---color
---require spec_helper
diff --git a/swagger-templates/ruby/spec_helper.mustache b/swagger-templates/ruby/spec_helper.mustache
deleted file mode 100644
index 8f4bb75..0000000
--- a/swagger-templates/ruby/spec_helper.mustache
+++ /dev/null
@@ -1,103 +0,0 @@
-=begin
-{{> api_info}}
-=end
-
-# load the gem
-require '{{{gemName}}}'
-
-# The following  was generated by the `rspec --init` command. Conventionally, all
-# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
-# The generated `.rspec` file contains `--require spec_helper` which will cause
-# this file to always be loaded, without a need to explicitly require it in any
-# files.
-#
-# Given that it is always loaded, you are encouraged to keep this file as
-# light-weight as possible. Requiring heavyweight dependencies from this file
-# will add to the boot time of your test suite on EVERY test run, even for an
-# individual file that may not need all of that loaded. Instead, consider making
-# a separate helper file that requires the additional dependencies and performs
-# the additional setup, and require it from the spec files that actually need
-# it.
-#
-# The `.rspec` file also contains a few flags that are not defaults but that
-# users commonly want.
-#
-# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
-RSpec.configure do |config|
-  # rspec-expectations config goes here. You can use an alternate
-  # assertion/expectation library such as wrong or the stdlib/minitest
-  # assertions if you prefer.
-  config.expect_with :rspec do |expectations|
-    # This option will default to `true` in RSpec 4. It makes the `description`
-    # and `failure_message` of custom matchers include text for helper methods
-    # defined using `chain`, e.g.:
-    #     be_bigger_than(2).and_smaller_than(4).description
-    #     # => "be bigger than 2 and smaller than 4"
-    # ...rather than:
-    #     # => "be bigger than 2"
-    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
-  end
-
-  # rspec-mocks config goes here. You can use an alternate test double
-  # library (such as bogus or mocha) by changing the `mock_with` option here.
-  config.mock_with :rspec do |mocks|
-    # Prevents you from mocking or stubbing a method that does not exist on
-    # a real object. This is generally recommended, and will default to
-    # `true` in RSpec 4.
-    mocks.verify_partial_doubles = true
-  end
-
-# The settings below are suggested to provide a good initial experience
-# with RSpec, but feel free to customize to your heart's content.
-=begin
-  # These two settings work together to allow you to limit a spec run
-  # to individual examples or groups you care about by tagging them with
-  # `:focus` metadata. When nothing is tagged with `:focus`, all examples
-  # get run.
-  config.filter_run :focus
-  config.run_all_when_everything_filtered = true
-
-  # Allows RSpec to persist some state between runs in order to support
-  # the `--only-failures` and `--next-failure` CLI options. We recommend
-  # you configure your source control system to ignore this file.
-  config.example_status_persistence_file_path = "spec/examples.txt"
-
-  # Limits the available syntax to the non-monkey patched syntax that is
-  # recommended. For more details, see:
-  #   - http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/
-  #   - http://www.teaisaweso.me/blog/2013/05/27/rspecs-new-message-expectation-syntax/
-  #   - http://rspec.info/blog/2014/05/notable-changes-in-rspec-3/#zero-monkey-patching-mode
-  config.disable_monkey_patching!
-
-  # This setting enables warnings. It's recommended, but in some cases may
-  # be too noisy due to issues in dependencies.
-  config.warnings = true
-
-  # Many RSpec users commonly either run the entire suite or an individual
-  # file, and it's useful to allow more verbose output when running an
-  # individual spec file.
-  if config.files_to_run.one?
-    # Use the documentation formatter for detailed output,
-    # unless a formatter has already been configured
-    # (e.g. via a command-line flag).
-    config.default_formatter = 'doc'
-  end
-
-  # Print the 10 slowest examples and example groups at the
-  # end of the spec run, to help surface which specs are running
-  # particularly slow.
-  config.profile_examples = 10
-
-  # Run specs in random order to surface order dependencies. If you find an
-  # order dependency and want to debug it, you can fix the order by providing
-  # the seed, which is printed after each run.
-  #     --seed 1234
-  config.order = :random
-
-  # Seed global randomization in this process using the `--seed` CLI option.
-  # Setting this allows you to use `--seed` to deterministically reproduce
-  # test failures related to randomization by passing the same `--seed` value
-  # as the one that triggered the failure.
-  Kernel.srand config.seed
-=end
-end
